apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: production-postgresql
  namespace: postgresql-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: postgresql
spec:
  instances: 3 # 1 primary + 2 read replicas for HA

  # PostgreSQL configuration
  postgresql:
    parameters:
      # Performance tuning for 3 instances
      max_connections: "200"
      shared_buffers: "256MB"
      effective_cache_size: "1GB"
      maintenance_work_mem: "64MB"
      checkpoint_completion_target: "0.9"
      wal_buffers: "16MB"
      default_statistics_target: "100"
      random_page_cost: "1.1"
      effective_io_concurrency: "200"
      # Logging
      log_statement: "all"
      log_min_duration_statement: "1000"
      log_line_prefix: "%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h "
      # Note: SSL and shared_preload_libraries are handled by CloudNativePG operator

  # Enable superuser access temporarily for user management
  enableSuperuserAccess: true

  # Monitoring configuration
  monitoring:
    enablePodMonitor: false # We'll create our own PodMonitor with correct labels

  # Storage configuration using Rook/Ceph
  storage:
    storageClass: rook-ceph-block
    size: 120Gi
    resizeInUseVolumes: true

  # Backup configuration using AWS S3
  backup:
    retentionPolicy: "7d"
    barmanObjectStore:
      destinationPath: "s3://postgresql-microk8s-one/postgresql-backups/production/"
      s3Credentials:
        accessKeyId:
          name: aws-s3-credentials
          key: ACCESS_KEY_ID
        secretAccessKey:
          name: aws-s3-credentials
          key: ACCESS_SECRET_KEY
      wal:
        compression: gzip
        maxParallel: 2
      data:
        compression: gzip
        jobs: 2
    target: primary

  # Tolerations for dedicated nodes (if needed)
  # tolerations:
  # - key: "postgresql"
  #   operator: "Equal"
  #   value: "true"
  #   effect: "NoSchedule"
